# -*- coding: utf-8 -*-
"""Modelo_evasao_cnpj_rais.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VcfpTdEZyb1rDUJBpdVoHw01aHGtdJqZ

# Dados do BSI

Os seguintes dados contém dados do BSI de 2013 a 2023 da UNIRIO. O CR No Período é o do primeiro período, o CR Atual é o CR na hora de evasão. Esses dados compreendem apenas pessoas que entraram após a adoção do SISU.

Os dados da RAIS foram comparados entre o ano de ingresso e o ano do quarto período.

Ano ingresso, Nome, ID (chave CPF), Curso, Forma de Ingresso, CR no 1o período, CR no 2o período, CR no 3o período, CR no 4o período, CRA no 4o período, Quota, Gênero, Empregado/Empresa durante os primeiros 4 períodos, Nota por disciplina (dos 4 primeiros períodos), desfecho (abandonou, não abandonou, cursando).
"""

pip install googletrans==4.0.0-rc1

import pandas as pd
import numpy as np
from pandas import DataFrame
import seaborn as sns
from google.colab import drive
import plotly.express as px
import plotly.graph_objects as go
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import ConfusionMatrixDisplay
from sklearn.metrics import classification_report
from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier, export_graphviz
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.svm import SVC
import graphviz
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
from sklearn.ensemble import HistGradientBoostingClassifier
from sklearn.datasets import load_iris
from googletrans import Translator
import joblib

"""# Carregando os dados"""

drive.mount('/content/gdrive/')

data = pd.read_excel("/content/gdrive/My Drive/dados_mestrado/data_cpf_modelo_bsi_evasao.xlsx")

data.head()

data_unicos = data.drop_duplicates(subset='NOME_PESSOA')

# prompt: Troque o nome da coluna Empresario para IsTheyBusinessperson

data.rename(columns={'Empresario':'IsTheyBusinessperson'}, inplace=True)
data_unicos.rename(columns={'Empresario':'IsTheyBusinessperson'}, inplace=True)

# Substituir os valores de 0 e 1 pelos novos rótulos
data_unicos['IsTheyBusinessperson'] = data_unicos['IsTheyBusinessperson'].replace({0: 'Nonentrepreneur', 1: 'Entrepreneur'})

data.rename(columns={'FORMA_EVASAO':'FINAL_STATUS'}, inplace=True)
data_unicos.rename(columns={'FORMA_EVASAO':'FINAL_STATUS'}, inplace=True)

# prompt: Usando o plotly, gere um gráfico de barras horizontal do percentual de cada data_unicos['IsTheyBusinessperson'] por FINAL_STATUS

import plotly.express as px

# Create a crosstab of IsTheyBusinessperson and FINAL_STATUS
crosstab = pd.crosstab(data_unicos['IsTheyBusinessperson'], data_unicos['FINAL_STATUS'])

# Calculate the percentage of each IsTheyBusinessperson by FINAL_STATUS
percentages = crosstab.div(crosstab.sum(axis=1), axis=0)

# Create a horizontal bar chart of the percentages
fig = px.bar(percentages, orientation='h', title='Percentage of IsTheyBusinessperson by FINAL_STATUS')

# Display the bar chart
fig.show()

"""# Análise Exploratória de CNPJ"""

translator = Translator()

translations = {
    'Empresário': translator.translate('Empresário', dest='en').text,
    'Não-empresário': translator.translate('Não-empresário', dest='en').text,
    'Concluido': translator.translate('Concluido', dest='en').text,
    'Evadido': translator.translate('Evadido', dest='en').text,
    'Contagem': translator.translate('Contagem', dest='en').text,
    'FORMA DE EVASÃO': translator.translate('FORMA DE EVASÃO', dest='en').text,
    'Gráfico de Barras de FORMA DE EVASAO comparado por valores de Empresário': translator.translate('Gráfico de Barras de FORMA DE EVASAO comparado por valores de Empresário', dest='en').text
}

# Substituir manualmente a tradução para garantir que "evasão" seja traduzido como "dropout"
translations['Evadido'] = 'Dropout'
translations['FORMA DE EVASÃO'] = 'Final Status of the Student'
translations['Gráfico de Barras de FORMA DE EVASAO comparado por valores de Empresário'] = translations['Gráfico de Barras de FORMA DE EVASAO comparado por valores de Empresário'].replace('Evasion', 'Dropout')

# Agrupar os dados
grouped_data = data_unicos.groupby(["IsTheyBusinessperson", "FINAL_STATUS"]).size().unstack().reset_index()

# Criar o gráfico de barras
fig = go.Figure()

# Adicionar dados para cada status final
fig.add_trace(go.Bar(
    y=grouped_data['IsTheyBusinessperson'],
    x=grouped_data['Concluido'],
    name=translations['Concluido'],
    orientation='h'
))

fig.add_trace(go.Bar(
    y=grouped_data['IsTheyBusinessperson'],
    x=grouped_data['Evadido'],
    name=translations['Evadido'],
    orientation='h'
))

# Atualizar layout do gráfico
fig.update_layout(
    barmode='stack',
    title=translations['Gráfico de Barras de FORMA DE EVASAO comparado por valores de Empresário'],
    xaxis_title=translations['Contagem'],
    yaxis_title=translations['Empresário'],
    yaxis=dict(
        tickmode='array',
        tickvals=['No', 'Yes'],
        ticktext=[translations['Não-empresário'], translations['Empresário']]
    )
)

# Mostrar o gráfico
fig.show()

"""Chi-square test between final status and employee-student: p-value = 0.384419. The result is not significant at p < .05."""

import matplotlib.pyplot as plt
from googletrans import Translator

# Criar instância do tradutor
translator = Translator()

# Tradução de valores únicos na coluna Categoria
unique_categories = data_unicos['Categoria'].unique()
translations = {category: translator.translate(category, dest='en').text for category in unique_categories}

# Substituir manualmente a tradução para garantir que "Evadido" seja traduzido como "Dropout"
translations['Evadido'] = 'Dropout'

# Adicionar as traduções adicionais para os rótulos e título
translations['Categoria'] = translator.translate('Categoria', dest='en').text
translations['Contagem'] = 'Count'
translations['Gráfico de Barras de Categoria (Empresário)'] = 'Bar Chart of Category (Entrepreneur)'

# Plotar o gráfico de barras horizontais
ax = data_unicos[data_unicos["IsTheyBusinessperson"] == 'Entrepreneur']["Categoria"].value_counts().plot(kind="barh")

# Atualizar os rótulos das barras com traduções
ax.set_yticklabels([translations[label.get_text()] for label in ax.get_yticklabels()])

# Adicionar rótulos e título traduzidos
plt.ylabel(translations['Categoria'])
plt.xlabel(translations['Contagem'])
plt.title(translations['Gráfico de Barras de Categoria (Empresário)'])

# Mostrar o gráfico
plt.show()

fig = px.box(data_unicos, y="CR_ATUAL", color="IsTheyBusinessperson")
fig.show()

data['IsTheyBusinessperson'] = data['IsTheyBusinessperson'].replace({0: 'Nonentrepreneur', 1: 'Entrepreneur'})

fig = px.box(data, y="MEDIA_FINAL", color = "IsTheyBusinessperson")
fig.show()

#Gere um gráfico de barras da coluna FINAL_STATUS comparado por valores de IsTheyBusinessperson

#data_unicos.groupby(["IsTheyBusinessperson", "FINAL_STATUS"]).size().unstack().plot(kind="barh")

# Gerar o gráfico de barras
ax = data_unicos.groupby(["IsTheyBusinessperson", "FINAL_STATUS"]).size().unstack().plot(kind="barh")



# Adicionar rótulos e título traduzidos
plt.ylabel(translations['Contagem'])
plt.legend(title='Final Status of the student', labels=['concluded', 'dropped out'])

# Mostrar o gráfico
plt.show()

from googletrans import Translator

translator = Translator()

translations = {
    'Empresário': translator.translate('Empresário', dest='en').text,
    'Não-empresário': translator.translate('Não-empresário', dest='en').text,
    'Concluido': translator.translate('Concluido', dest='en').text,
    'Evadido': translator.translate('Evadido', dest='en').text,
    'Contagem': translator.translate('Contagem', dest='en').text,
    'FORMA DE EVASÃO': translator.translate('FORMA DE EVASÃO', dest='en').text,
    'Gráfico de Barras de FORMA DE EVASAO comparado por valores de Empresário': translator.translate('Gráfico de Barras de FORMA DE EVASAO comparado por valores de Empresário', dest='en').text
}
# Substituir manualmente a tradução para garantir que "evasão" seja traduzido como "dropout"
translations['Evadido'] = 'Dropout'
translations['FORMA DE EVASÃO'] = 'Final Status of the Student'
translations['Gráfico de Barras de FORMA de EVASAO comparado por valores de Empresário'] = translations['Gráfico de Barras de FORMA DE EVASAO comparado por valores de Empresário'].replace('Evasion', 'Dropout')

# Gerar o gráfico de barras
ax = data_unicos.groupby(["IsTheyBusinessperson", "FINAL_STATUS"]).size().unstack().plot(kind="barh")

# Substituir os rótulos do eixo x
ax.set_xticklabels([translations['Não-empresário'], translations['Empresário']])

# Adicionar rótulos e título traduzidos
plt.xlabel(translations['Empresário'])
plt.ylabel(translations['Contagem'])
plt.legend(title=translations['FORMA DE EVASÃO'], labels=[translations['Concluido'], translations['Evadido']])

# Mostrar o gráfico
plt.show()

import plotly.graph_objects as go
import pandas as pd

# Supondo que você tenha os dados no DataFrame data_unicos
# data_unicos = ...

# Agrupando os dados
grouped_data = data_unicos.groupby(["IsTheyBusinessperson", "FINAL_STATUS"]).size().unstack()

# Criando o gráfico de barras horizontal
fig = go.Figure()

# Adicionando barras para Não-empresário
fig.add_trace(go.Bar(
    y=grouped_data.index,
    x=grouped_data['Concluido'],
    name='Concluido',
    orientation='h',
    marker=dict(color='rgb(55, 83, 109)')
))

# Adicionando barras para Evadido
fig.add_trace(go.Bar(
    y=grouped_data.index,
    x=grouped_data['Evadido'],
    name='Dropout',
    orientation='h',
    marker=dict(color='rgb(26, 118, 255)')
))

# Atualizando layout
fig.update_layout(
    barmode='stack',
    title='Bar Chart of Final Status of the Student by Businessperson Status',
    xaxis=dict(title='Count'),
    yaxis=dict(title='Businessperson Status', tickvals=[0, 1], ticktext=['Non-businessperson', 'Businessperson']),
    legend=dict(title='Final Status of the Student')
)

# Mostrando o gráfico
fig.show()

ax = data_unicos.groupby(["IsTheyBusinessperson", "ingresso_atual"]).size().unstack().plot(kind="bar")

# Substituir os rótulos do eixo x
ax.set_xticklabels([translations['Não-empresário'], translations['Empresário']])

# Adicionar rótulos e título traduzidos
plt.xlabel(translations['Empresário'])
plt.ylabel('Count')
plt.legend(title='Admission Method', labels=['Quotas', 'Non-Quotas'])
# Mostrar o gráfico
plt.show()

'''
df_IsTheyBusinessperson = data_unicos[data_unicos["IsTheyBusinessperson"] == 'Entrepreneur']
df_grouped = df_IsTheyBusinessperson.groupby(["Categoria", "FINAL_STATUS"]).size().unstack()

# Criando o gráfico de barras com Plotly Express
fig = px.bar(df_grouped, x=df_grouped.columns, y=df_grouped.index,
             title='Distribuição de Evasão por Categoria Social e Forma de Evasão',
             labels={'x': 'Categoria Social', 'y': 'Contagem'})

fig.show()
'''
data_unicos['Categoria'] = data_unicos['Categoria'].replace({
    'Fundou uma empresa durante a graduação': 'Founded a company during graduation',
    'Fundou uma empresa depois da graduação': 'Founded a company after graduation',
    'Fundou uma empresa antes de entrar na graduação': 'Founded a company before graduating'
})
data_unicos['FINAL_STATUS'] = data_unicos['FINAL_STATUS'].replace({
    'Concluido': 'Concluded',
    'Evadido': 'Dropped Out',
})

# Filtrando os dados para empresários
df_IsTheyBusinessperson = data_unicos[data_unicos["IsTheyBusinessperson"] == 'Entrepreneur']

# Agrupando os dados por "Categoria" e "FINAL_STATUS"
df_grouped = df_IsTheyBusinessperson.groupby(["Categoria", "FINAL_STATUS"]).size().unstack()

# Criando o gráfico de barras com Plotly Express
fig = px.bar(df_grouped, x=df_grouped.columns, y=df_grouped.index,
             title='Distribution of Dropout by Social Category and Dropout Form',
             labels={'x': 'Dropout Form', 'y': 'Count'})

fig.show()

"""# Análise Exploratória de RAIS"""

sns.countplot(y="employee_student", data=data)

fig = px.box(data_unicos, y="CR_ATUAL", color="employee_student")
fig.show()

fig = px.box(data, y="MEDIA_FINAL", color = "employee_student")
fig.show()

ax = data_unicos.groupby(["employee_student", "FINAL_STATUS"]).size().unstack().plot(kind="barh")



# Adicionar rótulos e título traduzidos
plt.ylabel(translations['Contagem'])
plt.legend(title='Final Status of the student', labels=['concluded', 'dropped out'])

# Mostrar o gráfico
plt.show()

import plotly.express as px

# Supondo que você tenha um DataFrame chamado data_unicos
# data_unicos = pd.read_csv('seu_arquivo.csv')  # Carregar seus dados se necessário

# Agrupar e contar os dados como no exemplo original
grouped_data = data_unicos.groupby(["employee_student", "FINAL_STATUS"]).size().unstack(fill_value=0)

# Converter para um DataFrame adequado para Plotly
plot_data = grouped_data.reset_index().melt(id_vars='employee_student', value_vars=grouped_data.columns)

# Criar o gráfico usando Plotly
fig = px.bar(plot_data,
             x='value',
             y='employee_student',
             color='FINAL_STATUS',
             orientation='h',
             labels={'value': 'Contagem', 'employee_student': 'Employee/Student', 'FINAL_STATUS': 'Final Status'},
             title='Final status of the student')

# Atualizar a legenda
fig.update_layout(legend_title_text='Final status of the student')

# Mostrar o gráfico
fig.show()

"""Chi-square test between final status and employee-student: p-value = 0.617251. The result is not significant at p < .05."""

# prompt: Baixe um xlxs de  data_unicos onde NOME_PESSOA = "HENRIQUE SOARES RODRIGUES"

data_unicos[data_unicos['NOME_PESSOA'] == "HENRIQUE SOARES RODRIGUES"].to_excel("/content/gdrive/My Drive/dados_mestrado/HENRIQUE_SOARES_RODRIGUES.xlsx")

"""# Usando SMOTE para balancear as classes"""

# Gere um dataset chamado data_modelo que é composto pelas seguintes colunas de data_unicos: ingresso_atual, MEDIA_FINAL, CR_ATUAL, CR_NO_PERIODO, FINAL_STATUS, IsTheyBusinessperson, Tempo_Evasao_Sociedade_Cat

data_modelo = data_unicos[['ingresso_atual', 'MEDIA_FINAL', 'CR_ATUAL', 'CR_NO_PERIODO', 'FINAL_STATUS', 'SEXO', 'IsTheyBusinessperson', 'Categoria', 'GPA1', 'GPA2', 'GPA3', 'GPA4','grade_programming1', 'grade_programming2', 'grade_basic_math','grade_calculus1', 'grade_linear_algebra', 'employee_student']]

# Transformar as colunas de data modelo que são categóricas, como ingresso_atual, FINAL_STATUS e Tempo_Evasao_Sociedade_Cat, em colunas numéricas
from sklearn.preprocessing import LabelEncoder

# Create a LabelEncoder object
le = LabelEncoder()

# Apply the label encoder to the categorical columns
data_modelo['ingresso_atual'] = le.fit_transform(data_modelo['ingresso_atual'])
data_modelo['FINAL_STATUS'] = le.fit_transform(data_modelo['FINAL_STATUS'])
data_modelo['Categoria'] = le.fit_transform(data_modelo['Categoria'])
data_modelo['IsTheyBusinessperson'] = le.fit_transform(data_modelo['IsTheyBusinessperson'])
data_modelo['SEXO'] = le.fit_transform(data_modelo['SEXO'])
data_modelo['employee_student'] = le.fit_transform(data_modelo['employee_student'])

#data_modelo

'''
from sklearn.preprocessing import LabelEncoder
import joblib
from google.colab import files

# Suponha que 'data_modelo' é o seu DataFrame de treinamento
colunas_categoricas = ['ingresso_atual', 'FINAL_STATUS', 'Categoria', 'IsTheyBusinessperson', 'SEXO', 'employee_student'] # Changed tuple to list

# Ajuste e salve os LabelEncoders
for coluna in colunas_categoricas:
    le = LabelEncoder()
    le.fit(data_modelo[coluna])
    joblib.dump(le, f'label_encoder_{coluna}.pkl')
    files.download(f'label_encoder_{coluna}.pkl')
'''

'''
from imblearn.over_sampling import SMOTE

smote = SMOTE(random_state=42)

X_resampled, y_resampled = smote.fit_resample(data_modelo.drop("IsTheyBusinessperson", axis=1), data_modelo["IsTheyBusinessperson"])

data_resampled = pd.concat([pd.DataFrame(X_resampled, columns=data_modelo.drop("IsTheyBusinessperson", axis=1).columns), pd.DataFrame(y_resampled, columns=["IsTheyBusinessperson"])], axis=1)

data_resampled.groupby("IsTheyBusinessperson").size().plot(kind="bar")
'''

"""# Decision Tree - CR acumulado



"""

X = data_modelo  [['ingresso_atual', 'CR_ATUAL', 'CR_NO_PERIODO', 'IsTheyBusinessperson', 'Categoria', 'SEXO' ,'grade_programming1', 'grade_programming2', 'grade_basic_math','grade_calculus1', 'grade_linear_algebra', 'employee_student']]
y = data_modelo  ['FINAL_STATUS']

# Realize a codificação de variáveis dummy
# X = pd.get_dummies(X, columns=['FINAL_STATUS', 'GENDER'])

# Divida os dados em conjuntos de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Crie o modelo da árvore de decisão
model = DecisionTreeClassifier( criterion='gini', min_impurity_decrease=0.005)
# Treine o modelo com os dados de treinamento
model.fit(X_train, y_train)

# Faça previsões com os dados de teste
y_pred = model.predict(X_test)

# Avalie o desempenho do modelo
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)

print("Model accuracy:", accuracy)
print("Report:\n", report)

from sklearn.tree import plot_tree

# Plote a árvore de decisão
plt.figure(figsize=(20, 10)) # Ajuste o tamanho da figura
plot_tree(model, feature_names=X.columns, class_names=['Graduated', 'Dropped Out'], filled=True) # Plote a árvore com os nomes das características e das classes
plt.show() # Mostre o gráfico

# Matriz de confusão

cm = confusion_matrix(y_test, y_pred)

labels = ["Graduated", "Droped out"]

cmd = ConfusionMatrixDisplay(cm, display_labels=labels)

cmd.plot(values_format="d")

plt.show()

"""# Gradient Boost - CR do primeiro periódo



"""

X = data_modelo  [['ingresso_atual', 'GPA1', 'IsTheyBusinessperson', 'Categoria', 'SEXO','grade_programming1', 'grade_programming2', 'grade_basic_math','grade_calculus1', 'grade_linear_algebra', 'employee_student']]
y = data_modelo  ['FINAL_STATUS']

# Realize a codificação de variáveis dummy
# X = pd.get_dummies(X, columns=['FINAL_STATUS', 'GENDER'])

# Divida os dados em conjuntos de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a HistGradientBoostingClassifier model
model = HistGradientBoostingClassifier()

# Train the model with the data
model.fit(X_train, y_train)

# Faça previsões com os dados de teste
y_pred = model.predict(X_test)

# Avalie o desempenho do modelo
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)

print("Model accuracy:", accuracy)
print("Report:\n", report)

# Matriz de confusão

cm = confusion_matrix(y_test, y_pred)

labels = ["Graduated", "Droped out"]

cmd = ConfusionMatrixDisplay(cm, display_labels=labels)

cmd.plot(values_format="d")

plt.show()

"""# Gradient Boost - CR do primeiro e segundo periódos

"""

from sklearn.ensemble import HistGradientBoostingClassifier
X = data_modelo  [['ingresso_atual', 'GPA1', 'GPA2','IsTheyBusinessperson', 'Categoria', 'SEXO' ,'grade_programming1', 'grade_programming2', 'grade_basic_math','grade_calculus1', 'grade_linear_algebra','employee_student']]
y = data_modelo  ['FINAL_STATUS']

# Realize a codificação de variáveis dummy
# X = pd.get_dummies(X, columns=['FINAL_STATUS', 'GENDER'])

# Divida os dados em conjuntos de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)



# Create a HistGradientBoostingClassifier model
model = HistGradientBoostingClassifier()

# Train the model with the data
model.fit(X_train, y_train)

# Faça previsões com os dados de teste
y_pred = model.predict(X_test)

# Avalie o desempenho do modelo
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)

print("Model accuracy:", accuracy)
print("Report:\n", report)

# Matriz de confusão

cm = confusion_matrix(y_test, y_pred)

labels = ["Graduated", "Droped out"]

cmd = ConfusionMatrixDisplay(cm, display_labels=labels)

cmd.plot(values_format="d")

plt.show()

"""# Gradient Boost - CR do primeiro, segundo e terceiro periódos

"""

X = data_modelo  [['ingresso_atual', 'GPA1', 'GPA2','GPA3', 'IsTheyBusinessperson', 'Categoria', 'SEXO','grade_programming1', 'grade_programming2', 'grade_basic_math','grade_calculus1', 'grade_linear_algebra', 'employee_student']]
y = data_modelo  ['FINAL_STATUS']

# Realize a codificação de variáveis dummy
# X = pd.get_dummies(X, columns=['FINAL_STATUS', 'GENDER'])

# Divida os dados em conjuntos de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a HistGradientBoostingClassifier model
model = HistGradientBoostingClassifier()

# Train the model with the data
model.fit(X_train, y_train)

# Faça previsões com os dados de teste
y_pred = model.predict(X_test)

# Avalie o desempenho do modelo
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)

print("Model accuracy:", accuracy)
print("Report:\n", report)

# Matriz de confusão

cm = confusion_matrix(y_test, y_pred)

labels = ["Graduated", "Droped out"]

cmd = ConfusionMatrixDisplay(cm, display_labels=labels)

cmd.plot(values_format="d")

plt.show()

"""# Gradient Boost - CR do primeiro, segundo, terceiro e quarto periódos

"""

X = data_modelo  [['ingresso_atual', 'GPA1', 'GPA2','GPA3', 'GPA4', 'IsTheyBusinessperson', 'Categoria', 'SEXO','grade_programming1', 'grade_programming2', 'grade_basic_math','grade_calculus1', 'grade_linear_algebra','employee_student']]
y = data_modelo  ['FINAL_STATUS']

# Realize a codificação de variáveis dummy
# X = pd.get_dummies(X, columns=['FINAL_STATUS', 'GENDER'])

# Divida os dados em conjuntos de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a HistGradientBoostingClassifier model
model = HistGradientBoostingClassifier()

# Train the model with the data
model.fit(X_train, y_train)

# Faça previsões com os dados de teste
y_pred = model.predict(X_test)

# Avalie o desempenho do modelo
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)

print("Model accuracy:", accuracy)
print("Report:\n", report)

# Matriz de confusão

cm = confusion_matrix(y_test, y_pred)

labels = ["Graduated", "Droped out"]

cmd = ConfusionMatrixDisplay(cm, display_labels=labels)

cmd.plot(values_format="d")

plt.show()

import random

# Generate random indices within the test data range
random_indices = random.sample(range(len(X_test)), 3)

# Select random instances from X_test based on the generated indices
random_instances = X_test.iloc[random_indices]

# Predict the target values for the selected instances
predicted_values = model.predict(random_instances)

# Print the actual and predicted values
print("Actual values:", y_test.iloc[random_indices])
print("Predicted values:", predicted_values)

# Salve o modelo
#joblib.dump(model, 'model4GPA.pkl')

#from google.colab import files

# Baixar o arquivo do modelo
#files.download('model4GPA.pkl')

'''
data_modelo = data_unicos[['ingresso_atual', 'MEDIA_FINAL', 'CR_ATUAL', 'CR_NO_PERIODO', 'FINAL_STATUS', 'SEXO', 'IsTheyBusinessperson', 'Categoria', 'GPA1', 'GPA2', 'GPA3', 'GPA4','grade_programming1', 'grade_programming2', 'grade_basic_math','grade_calculus1', 'grade_linear_algebra', 'employee_student']]
# Create a LabelEncoder object
le = LabelEncoder()

# Apply the label encoder to the categorical columns
data_modelo['ingresso_atual'] = le.fit_transform(data_modelo['ingresso_atual'])
data_modelo['FINAL_STATUS'] = le.fit_transform(data_modelo['FINAL_STATUS'])
data_modelo['Categoria'] = le.fit_transform(data_modelo['Categoria'])
data_modelo['IsTheyBusinessperson'] = le.fit_transform(data_modelo['IsTheyBusinessperson'])
data_modelo['SEXO'] = le.fit_transform(data_modelo['SEXO'])
data_modelo['employee_student'] = le.fit_transform(data_modelo['employee_student'])
X = data_modelo  [['ingresso_atual', 'GPA1', 'GPA2','GPA3', 'GPA4', 'IsTheyBusinessperson', 'Categoria', 'SEXO','grade_programming1', 'grade_programming2', 'grade_basic_math','grade_calculus1', 'grade_linear_algebra','employee_student']]
y = data_modelo  ['FINAL_STATUS']


# Divida os dados em conjuntos de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a HistGradientBoostingClassifier model
model = HistGradientBoostingClassifier()

# Train the model with the data
model.fit(X_train, y_train)

# Faça previsões com os dados de teste
y_pred = model.predict(X_test)

# Avalie o desempenho do modelo
accuracy = accuracy_score(y_test, y_pred)

joblib.dump(model, 'model4GPA.pkl')

files.download('model4GPA.pkl')
'''